<h1>An asynchronous HTTP transaction</h1>

<p>In the <a class="blog_prev" href="#" title="Previous blog post">previous post</a> the D&amp;B Direct+ API was called synchronously and that seemed to work just fine. The thing is that using synchronous I/O calls in Node.js violates best programming practices but that leads us to the question "Why is this so"? The short answer, in my opinion, is "waiting for I/O to complete in Node.js is suboptimal because the main thread is just a single thread and, as a programmer, your aim should be to keep this thread open &amp; ready to process code at all times". I don't blame you if you don't want to take my word for it, but, if that is the case, I would definitely recommend this <a href="https://youtu.be/8aGhZQkoFbQ" title="What the heck is the event loop anyway?">YouTube video</a>. There is another point to be made though, Node.js shields programmers from the <a href="http://bholley.net/blog/2015/must-be-this-tall-to-write-multi-threaded-code.html" title="Must be This Tall to Write Multi-Threaded Code">complexities of writing multi-threaded code</a> but, at the same time, still is able to make use of multiple threads. This is especially true when asynchronous calls are executed. I would like to recommend the following <a href="https://youtu.be/zphcsoSJMvM" title="The Node.js Event Loop: Not So Single Threaded">YouTube video</a> in case you are confused by this paradox.</p>

<p>So, now that everybody is on board for making asynchronous calls, let's rework the code for making a D&amp;B Direct+ identity resolution call:</p>

<script src="https://gist.github.com/hdr1001/b49d50d2d0fba9cc46dbbb7662b8f14b.js" type="text/javascript"></script>

<p>In this version of the code the processing of the HTTP transaction is clearly split up into two distinct parts. The HTTP transaction is initiated in function get_1st_mc_name_async. In this function some groundwork is done (related to the web service URL &amp; HTTP headers) and then the request is fired off: <code>https.request(httpAttr.reqOpts, callbck).end();</code> In this method invocation a callback function is registered as well. The callback is related to the second part of the HTTP transaction, the processing of the response. In this function, function cb, the name of the first match candidate generated by D&amp;B is determined.</p>

<p>Running the code will give you the following results:</p>

<p><img src="/dev/blog/imgs/idr_async_req_v1.png" alt="Result asynchronous IDR request (v1)" /></p>

<p>Important point to note here is that, immediately after executing function get_1st_mc_name_async, variable sName is still undefined. The value associated with this variable will only be available after processing the callback. This might be counterintuitive if you're used to working with more traditional programming languages. Just keep in mind that, once you get the hang of it, it all makes perfect sense.</p>
